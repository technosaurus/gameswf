Chunked LOD demo
5 Aug 2002
Thatcher Ulrich <tu@tulrich.com> http://tulrich.com

Demo of chunked LOD scheme.  Uses static meshes with lerping and
crack-filling skirt meshes to give an adjustable guaranteed max pixel
error, no vertex popping and low CPU overhead.  Uses a texture
quadtree scheme to tile massive, seamless geospecific (unique)
textures over large models, using ordinary OpenGL 1.2 functionality.
Loads data in a separate thread, to avoid making the rendering thread
wait for IO.

There are several programs in this package:

* chunkdemo -- the renderer; reads .chu and .tqt or .jpg files, and
  lets you fly around the terrain interactively.  If you just want to
  see the demo, this is the program you want.

* heightfield_chunker -- the tool that precomputes the chunk data, to
  make .chu files.  Reads .bt (Binary Terrain) heightfield files for
  input.

* maketqt -- a preprocessing tool that generate a .tqt (texture
  quadtree) file, from an input .jpg file.  Input and output size not
  limited by available RAM.

* heightfield_shader -- a simple-minded heightfield shading tool.  Can
  generate a gigantic texture to drape over a terrain.  Works on a
  scanline at a time; the output size of the texture is not limited by
  available RAM.

* makebt -- utility to make a .bt file from a .png file.

* decimate_texture -- utility to do a very coarse subsampling of a
  giant .jpg file, to make a smaller .jpg file.  Useful for previewing
  a draft view of large .jpgs.

* dem2bt.pl -- quickie Perl script to make a .bt file from USGS ASCII
  .dem file.

All programs print some usage info when run from the command line.

With NVIDIA's vertex_array_range extension, the demo puts out up to
9.5 million tris/sec at 30 fps on my laptop (1GHz CPU, GeForce2 Go
video) under optimal conditions.  NVIDIA's VAR demo does ~11 Mtris/s
on this machine, so I'm doing pretty well.  Typical throughput is a
little lower than that, but still excellent considering the size and
visual quality of the rendering.

The strips currently generated by the chunker have a lot of degenerate
tris in them; typically more than 0.5x the number of real triangles,
so I think throughput improvement is possible.  I'm just using the
automatic binary-triangle-tree strip generation approach from the
Lindstrom et al SIGGRAPH '96 paper.  A stripifier designed for
arbitrary meshes might be able to do better.

Thanks to John Ratcliff for the crater dataset,
http://ratcliff.flipcode.com

Thanks to Ben Discoe & http://www.vterrain.org for the .bt terrain
file format and for providing some sample .bt data.

Thanks to Ken Musgrave & http://www.pandromeda.com for some nice
procedural sample data.

Thanks to Peter Lindstrom, University of Washington and Georgia Tech
for preparing and hosting the Puget Sound dataset:
http://www.cc.gatech.edu/projects/large_models/

Thanks to the USGS for collecting data and making it available to the
public.

Thanks to Mike Shaver, Thierry Berger-Perrin and Ignacio Castaño for
patches to fix bugs and improve Linux support.

The source code for these programs has been donated to the public
domain; do whatever you want with it.  The home page of this project
is:

	http://tulrich.com/geekstuff/chunklod.html

You can find links to the CVS repository, sample data, and more
documentation there.


USAGE
=====

To view the included crater dataset, run "chunkdemo".  By default it
will look for "crater/crater.chu" and "crater/crater.jpg", and print
some usage info to the console.

To easily view the preprocessed datasets available from the project
homepage, you can run "lua demo_menu.lua".  This shows a text menu of
the various datasets, and launches chunkdemo with the necessary
arguments.

To experiment with other datasets, you need to generate a .chu file
from heightfield data, using the heightfield_chunker program.  If you
run "heightfield_chunker" with no arguments, it will print a usage
summary.  For heightfield data input, you must use the .BT format,
which is a nice convenient format for high-precision terrain data.
This package contains a couple utility programs for making .bt data
from other heightfield file formats.

Run the chunker with "heightfield_chunker input.bt output.chu".  The
program picks some default values for the base error ("-e error") and
tree depth ("-d depth").  Watch the output summary, to see if you
might want to change the default values.  In general, a larger base
error value will generate smaller, less detailed chunk files.  For
tree depth, a higher value is better for bigger datasets, but too high
a value will make chunks without enough vertices in them, and the
overall overhead will be larger.  You probably want an average vertex
per chunk value of somewhere between 1000 and 5000.  That's just a
guess; I haven't systematically explored the tradeoffs.

For less fidelity and smaller data files, you can try raising the base
error value.

You can get some nice sample .BT data at:
http://vterrain.org/BT/index.html .

If you don't have a texture for your dataset, you can make a basic one
using "heightfield_shader".  Example:

	heightfield_shader heightfield.bt output_texture.jpg -g gradient.png

There are various options; run "heightfield_shader" with no args to
see a usage summary.  You can use the generated texture as-is, but
depending on your hardware you may not be able to see any resolution
above say 2048 x 2048 texels.  For really big textures, use the
"maketqt" program to chop up your .jpg file into a texture quadtree.
Example:

	maketqt texture.jpg texture.tqt

For best results, you will want to look at the options of maketqt.
It's not very smart about defaults.

To view the heightfield, use "chunkdemo chunkdata.chu
texture.[jpg|tqt]".  The program will open a rendering window, and
print usage info to the console.  There are some command-line options
to chunkdemo that control resolution, fullscreen rendering, bitdepth,
etc.  Run without args for a summary.


CHANGES
=======

5 Aug 2002

This is basically the version I showed at SIGGRAPH, with a couple bug
fixes.  All the basic functionality is working well; paging of massive
datasets, texture quadtree tiling, LOD with morphing.


ALGORITHM NOTES
===============

Quick summary:

Take a single object, and make a tree of chunks out of it.  Each chunk
is just a static, precomputed mesh that can be rendered with a single
glDrawElements() call.  The chunk at the root of the tree is a
low-detail representation of the entire object.  The child chunks of
the root node split the object into several pieces, and each piece
independently represents its portion of the object, with a higher
level of detail than the parent.  This splitting happens recursively
down to some arbitrary depth.  Each chunk has a bounding volume
associated with it, and each level of the tree has a maximum geometric
error associated with the chunks at that level.  The max geometric
error represents maximum deviation of a chunk mesh from the underlying
object geometry it represents.  In my scheme the max geometric error
reduces by a factor of 2 at every additional level in the tree.  For
example, if the root node of the tree is a single mesh that represents
the object with at most 16 units of deviation from the full-detail
mesh, at the fifth level down the tree, the chunks each represent a
small piece of the object, with only 1 unit of deviation.

There is a paper at http://tulrich.com/geekstuff/chunklod.html which
has much more detail, and covers the interesting parts like morphing,
crack filling, and texturing.


BUILDING
========

Windows and Linux users
-----------------------

1. You should have gotten source code along with the demo, of the same
   version used to build the demo.  For up-to-date code, see
   http://tulrich.com/geekstuff/chunklod.html

Linux Users
-----------

2. You may need to install the development files for Lua 4.0 .  Lua is
   a lightweight but easy-to-use and powerful scripting language, see
   http://www.lua.org for details.  Install lua alongside the
   tu-testbed tree.  For example, if you untarred this project into
   "~/src/tu-testbed/*", then you should put lua in "~/src/lua-4.0".
   If you already have Lua installed somewhere on your system, or you
   want to install it somewhere else, just edit the tu-testbed/config
   file to set the appropriate paths.

3. Make sure you have SDL version 1.2 (or better) installed.  SDL is a
   very popular and widely ported compatibility layer, for access to
   multimedia hardware & interfaces.  See http://www.libsdl.org for
   details.

4. "cd tu-testbed; make"

   Hopefully that does it.  If not, you should look through
   "tu-testbed/config" to make sure you have the other necessary
   libraries, such as libjpeg and libpng.  Most distros will include
   those libs by default.

Windows Users
-------------

2. You need a version of GNU make.  The default Makefiles are set up
   to compile cleanly with the command-line version of MSVC 6.0, but
   GNU make drives the build.

   I use Cygwin under Win32, to provide GNU make and other handy *nix
   tools.  See http://sources.redhat.com/cygwin/

   You may also be able to find GNU make for Win32 without inhaling so
   much *nix.  See http://www.mingw.org for example, or
   http://unxutils.sourceforge.net/

   You can also try dropping everything into a MSVC IDE project if
   you're so inclined.  Theoretically it should work, but I've never
   tried it.

3. You need these libraries:

   Lua -- see http://www.lua.org

   SDL -- see http://www.libsdl.org

   Jpeglib -- see http://www.ijg.org

   libpng -- see http://www.libpng.org

   By default the Makefiles expect these to be installed alongside
   tu-testbed.  You can change the paths by going into
   "tu-testbed/config"; it should be self-explanatory.

4. Open a shell, and do:
   
   > cd tu-testbed
   > make

   Hopefully it works.  The various Chunked LOD executables are in
   tu-testbed/demos/chunklod/


HISTORY
=======

The Chunked LOD software was written primarily between late July 2001
and early August 2002.  A neat, one-year side project.  In April 2001
I had begun working for Oddworld Inhabitants, and during the summer I
was on-site in San Luis Obispo CA, pushing hard to help finish Munch's
Oddysee for the Xbox launch.  I was away from home, living in a hotel,
working long hours alongside some LOD experts like Jonathan Blow and
Charles Bloom.  Under the circumstances I didn't have much time or
energy for things outside of work, so my blowing-off-steam activities
consisted mostly of hiking and mountain biking in the early mornings
in the mountains in and around SLO, and messing with an old Linux
laptop I kept in my hotel room.

It seems crazy that I would have started a programming side-project
during high-pressure crunch mode on a game, but actually it made some
sense: my work on the game involved much heavy slogging through an
unfamiliar engine, including a lot of non-graphics work; I was getting
a lot of intellectual stimulation every day by talking to the other
programmers about various topics of interest; and prior to starting at
Oddworld I had just finished working on another terrain engine for the
game Soul Ride, so the ideas were percolating, they just needed an
outlet.

The thinking that leads up to Chunked LOD goes back a few years.  The
idea of quadtree tiling was planted in my mind sometime in 1996.  I
had seen Michael Abrash's talk in April 1996 at the Computer Game
Developers Conference, where he talked about Quake.  The concept of
surface caching really blew my mind, and sparked all kinds of
thinking.  I had been working with loose octrees for database
organization around that time, and I realized that quadtree tiling
with surface caching and procedural generation would be a fantastic
way to handle tons of texture detail.  Then, I considered it "the way
of the future".  Six years later, it *still* seems to be the way of
the future...

I was working for Tectrix Fitness Equipment at the time.  In 1997 I
had a chance to try out quadtree tiling with the engine for a tank
combat game I was working on.  This saw the light of day as the
creatively-titled "Tank" for VR Bike & VR Climber.  The game as
released was much less ambitious than the original design, due to
corporate circumstances, and doesn't show off the texturing nearly as
well as some of the earlier demos.  But the concept is there: quadtree
tiling, surface caching, procedural generation (using geotypical tiles
and vector outlines of terrain types), and lightmap shading baked into
the cached textures.  This was all software rendered.  IMHO it looked
pretty swank, for that era of hardware.

In 1998 I started working on Soul Ride, a terrain-focused snowboarding
simulation.  I did a lot of work on geometric LOD for that project,
which is documented elsewhere.  Quadtree tiling made its way into the
end product here as well, in a much more aggressive form.  As the
project wound down in late 2000 I participated in some good
discussions with people on the gdalgorithms mailing list, notably Tom
Forsyth and Charles Bloom, about LOD for games.  This is when I
started to seriously consider the idea of using static mesh
connectivity for LOD.  At first I had a bunch of fairly minor ideas
about how to refine the fine-grained adaptive quadtree I was using in
Soul Ride.

During the same time, Sean Barrett started a private email discussion
amongst a few developers about terrain rendering, wanting to explore
the state-of-the-art for something he was working on.  His ideas &
demo about insisting on morphing, and the distribution of detail
vs. distance convinced me, and pushed me towards the concept of
Chunked LOD.  I didn't have time to try it out then, but I was
confident about the basic idea.  Confident enough, that when I started
at Oddworld in April 2001, I pronounced geometric LOD as a "solved
problem" when talking with Charles and Jonathan.

Jon, correctly, begged to differ with my rash statement, of course --
his objection was mainly that shading had become the most important
driver of visual quality, not geometric detail, so anything that
compromised shading in any way would necessarily lose.  I tend to be
doggedly wedded to the concept of scalability, so my feeling was that
a Chunked LOD approach would still let you do any shading you wanted
to, since it essentially uses static meshes, but give the benefits of
LOD.  I was motivated to write a demo, to prove out the idea.  Jon's
objection is still a good one, I think, and may yet prevail.  This
also helped motivate my decision to release the Chunked LOD work as
freely as possible -- one of the ways that LOD can compromise shading
is by absorbing developer time, so by making code freely available,
hopefully LOD can be used by some busy programmers who otherwise
wouldn't have time for it.

The actual amount of code is not very large, and the ideas themselves
are straightforward and built on things I was familiar with, so I had
a basic demo going within a month or two.  I showed it to the people
at work, and I remember Charles pronouncing it "promising".  I
released cleaned up versions to the 'net in October and November, and
mostly stopped working on it.  I got some very helpful patches and
correspondence as a result of those releases.  In early 2002, Mike
Capps asked me to give a talk on terrain rendering at his SIGGRAPH
2002 course, "Super-Size It!"  I wrote up the course notes in the
spring of 2002, and of course that sparked a bunch of implementation
ideas, so between then and late July, I focused on adding things like
paging and quadtree texture tiling.  The 16K x 16K Puget Sound dataset
was the driver for these features; Hughes Hoppe had released a nice
Progressive Mesh demo rendering the Puget data, and the
Lindstrom/Pascucci paper & movie showed that it was possible to handle
the whole thing out-of-core in real time.  I knew my approach had a
few inherent advantages in terms of triangle rate, texturing, and
simplicity relative to those demos, so that was my focus leading up to
SIGGRAPH.

After SIGGRAPH, I cleaned up a few things, released it, and considered
it basically done.  I think it's a nice demo, and hopefully the work
will find its way into useful applications.
