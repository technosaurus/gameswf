Bugs
====

* there's a pop when transitioning from textured to mesh-rendered
  glyphs; probably the texture fonts aren't registered exactly right?


Productizing
============

Tasks to make gameswf ready for including in real games.

* hooks so that preprocessor and loader can deal with special,
  host-specific data like vertex buffers and textures in a custom way
  if desired.

* fix memory leaks, need reference counting

* pick a version number, post a release


General
=======

* implement host-app driven text rendering functions (maybe handy, but
  not essential)

* sprites as button characters are not working.  (Maybe they are
  now??)

* host-to-gameswf data transfer:

  * DONE set_variable

  * maybe augment this with array element parsing, and more data types?

  * ability to call ActionScript functions?  Might be the most
    flexible way to support arbitrary communication needs.
    Data-binding issues; would this mean exposing as_value in
    gameswf.h?  Probably.

	Should the whole ActionScript API be available to the host?
	I.e. let C++ host code and ActionScript code call back and forth?
	Might be really hot for translating slow prototype ActionScripts
	into C++.  Prototype in Flash on a fast machine, convert the
	scripts and deliver a blazing fast executable.

* DONE gameswf-to-host data transfer:

  * via host-pull, using get_variable()

  * via gameswf-push, using fscommand()

* Would be good if one of the log options produced a nice usable
  human-readable parsing of the file.  Or even a SSWF equivalent?


ActionScript
============

* all event hooks

* arrays, object constructors

* sprites can receive button events!  Like mouse down/up, etc.  So
  need the appropriate machinery for watching the mouse.

* make sure the frame semantics are correct.  I'm not 100% clear on
  the semantics of frame transitions.  I think that "being on frame N"
  means that N's tags and actions have been executed.

* collect a canonical set of test movies and check them into CVS

* generate or collect some game-gui-like movies

* will need some good test programs to make sure VM is doing the right
  thing.

* implement remaining opcodes and library functions


Renderer
========

* optimize tesselator (not super-high priority, caching works pretty
  well)

  * improve naive (mis)use of array<>; use a more statically-allocated
    array to hold intermediate results.

  * examine use of qsort; should probably use pointers to stuff in
    some situations, instead of raw copies

  * coarse clip/cull

  * better tesselation; look at Shewchuck's constrained delaunay stuff
    or the improved trapezoid tesselator that doesn't cut across the
    whole shape

* real lines (low priority)

  I think the way to handle this is to take advantage of a (mipmapped)
  circle texture, say 16x16, and actually draw rectangles.  But then
  it still doesn't seem too easy to get right.  Needs more thinking.
  Not a super high priority; doesn't seem to be a critical feature for
  most movies.

* Idea for antialiasing.  I really miss antialiasing; it sure would be
  nice to have it.  (But this is low priority for productizing; it
  should be easy enough for designers to work around gameswf's
  limitations.)  So here's the idea:

  * do full-blown expensive cached tesselation, to generate a "fringe
    mesh" around the outside edges of shapes.  We know the range of
    desired rendering sizes (in pixels), so we can make a fringe mesh
    that will range from 1 to 2 pixels in width when rendered.  I
    believe this involves shrinking the interior of the mesh by the
    equivalent of a half-pixel.

  * render the mesh using the dual-textured modulate thing, to fade
    the edge.  Adjust the U coordinates of the outer edge of the
    fringe according to the actual size in pixels of the fringe;
    i.e. if the fringe is being rendered at 1.27 pixels in size,
    adjust U so that the alpha fades to exactly 0 when the fringe is
    1.0 pixel from the interior; the excess fringe has alpha == 0 so
    doesn't render.

  This sounds pretty foolproof to me.  It's expensive in terms of
  precomputation, but then we have all this precomputation machinery
  anyway, so no big deal.  There could possibly be a pop when
  tesselations switch, although I don't think it would be any worse
  than existing pops, and I haven't noticed any objectionable popping
  with our existing shape rendering.

  Self-intersection of the expanded/shrunk mesh is a bitch.
  E.g. concave vertices, and tiny holes (like in minified text).
