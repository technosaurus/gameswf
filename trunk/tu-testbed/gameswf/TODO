Bugs
====

* there's a pop when transitioning from textured to mesh-rendered
  glyphs; probably the texture fonts aren't registered exactly right?


Productizing
============

Tasks to make gameswf ready for including in real games.

* ActionScript is not case sensitive (for variable and character
  names)!  But gameswf is!  Fix gameswf.

* hooks so that preprocessor and loader can deal with special,
  host-specific data like vertex buffers and textures in a custom way
  if desired.

  Textures are higher priority than meshes.  Approach: defer texture
  creation until after the load is finished.  Provide an API for the
  host to grab all images used in the movie, create bitmap_info's, and
  push them back in.  Also provide a load-time option to skip
  textures, so the host can push in pre-generated textures of its own.

* when prebuilding textures, it should be possible to down-sample the
  textures based on the scale they are actually displayed at.  This is
  so that res-happy artists can author with high-quality assets, but
  not penalize the game at run-time so much.

* pick a version number, post a release

* for data binding, we have:

  gameswf-push (fscommand)
  host-push (call_method, set_variable)
  host-pull (call_method, get_variable)
  
  we are missing gameswf-pull.  This would be useful for things like
  looking up localized text in the game engine's translation table,
  among other things.


General
=======

* implement host-app driven text rendering functions (maybe handy, but
  not essential)

* sprites as button characters are not working.  (Maybe they are
  now??)

* Would be good if one of the log options produced a nice usable
  human-readable parsing of the file.  Or even a SSWF equivalent?


ActionScript
============

* all event hooks

* arrays, object constructors

* sprites can receive button events!  Like mouse down/up, etc.  So
  need the appropriate machinery for watching the mouse.

* make sure the frame semantics are correct.  I'm not 100% clear on
  the semantics of frame transitions.  I think that "being on frame N"
  means that N's tags and actions have been executed.

* collect a canonical set of test movies and check them into CVS

* generate or collect some game-gui-like movies

* will need some good test programs to make sure VM is doing the right
  thing.  SET UP AUTOMATED REGRESSION TESTS -- can be a shell script
  that runs test movies in verbose mode and compares ActionScript
  logging against expected output.

* implement remaining opcodes and library functions


Renderer
========

* optimize tesselator (not super-high priority, caching works pretty
  well)

  * improve naive (mis)use of array<>; use a more statically-allocated
    array to hold intermediate results.

  * examine use of qsort; should probably use pointers to stuff in
    some situations, instead of raw copies

  * coarse clip/cull

  * better tesselation; look at Shewchuck's constrained delaunay stuff
    or the improved trapezoid tesselator that doesn't cut across the
    whole shape

* real lines (low priority)

  I think the way to handle this is to take advantage of a (mipmapped)
  circle texture, say 16x16, and actually draw rectangles.  But then
  it still doesn't seem too easy to get right.  Needs more thinking.
  Not a super high priority; doesn't seem to be a critical feature for
  most movies.

* Idea for antialiasing.  I really miss antialiasing; it sure would be
  nice to have it.  (But this is low priority for productizing; it
  should be easy enough for designers to work around gameswf's
  limitations.)  So here's the idea:

  * do full-blown expensive cached tesselation, to generate a "fringe
    mesh" around the outside edges of shapes.  We know the range of
    desired rendering sizes (in pixels), so we can make a fringe mesh
    that will range from 1 to 2 pixels in width when rendered.  I
    believe this involves shrinking the interior of the mesh by the
    equivalent of a half-pixel.

  * render the mesh using the dual-textured modulate thing, to fade
    the edge.  Adjust the U coordinates of the outer edge of the
    fringe according to the actual size in pixels of the fringe;
    i.e. if the fringe is being rendered at 1.27 pixels in size,
    adjust U so that the alpha fades to exactly 0 when the fringe is
    1.0 pixel from the interior; the excess fringe has alpha == 0 so
    doesn't render.

  This sounds pretty foolproof to me.  It's expensive in terms of
  precomputation, but then we have all this precomputation machinery
  anyway, so no big deal.  There could possibly be a pop when
  tesselations switch, although I don't think it would be any worse
  than existing pops, and I haven't noticed any objectionable popping
  with our existing shape rendering.

  Self-intersection of the expanded/shrunk mesh is a bitch.
  E.g. concave vertices, and tiny holes (like in minified text).

  Reasons not to mess with this:

  * sounds like a bunch of work

  * non-antialiased rendering on Xbox does not look that bad.

  * hardware keeps getting better; could just turn on multisample
    rendering

  * artists can work around it
