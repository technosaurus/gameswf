Bugs
====

* there's a pop when transitioning from textured to mesh-rendered
  glyphs; probably the texture fonts aren't registered exactly right?


Productizing
============

Tasks to make gameswf ready for including in real games.

* hooks so that preprocessor and loader can deal with special,
  host-specific data like vertex buffers and textures in a custom way.

* fix memory leaks

* pick a version number, post a release

* use Sint16 TWIP coordinates in all reasonable places to cut down on
  memory and processing.


General
=======

* text rendering is almost production-ready, so finishing touches here
  are a high priority.  In particular:

  * implement host-app driven text rendering functions

  * try it out; maybe add a little text output to chunklod or
    something

* sprites as button characters are not working.  (Maybe they are
  now??)

* host-app to gameswf communication

  * some mechanism for gamepad-like control of SWF UI's.  SWF is
    oriented around a mouse & keyboard model, which is not a good fit
    for consoles (and console-like) UI's.  Not sure exactly what to do
    about this.  One element would be associating SWF buttons with
    specific gamepad/keyboard buttons, which could be done by tagging
    the buttons in the SWF with special names, and adding an API for
    the host to report gamepad button presses.  Another element is
    dealing with dpad selections, where the user uses
    up/down/left/right buttons to highlight different options on the
    screen, and then another button to accept.  Not sure of the best
    way to shoehorn this into SWF.

    Current best idea: map gamepad buttons to keyboard keys, and use
    ActionScript to interpret keypresses.  Need enough ActionScript
    support so that this works.

* text entry?  No keyboard on consoles, text input is very platform
  specific; low priority for now.

* named elements APIs, for easier UI programming in the host app.
  Should the whole ActionScript API be available to the host?  Might
  be really hot for translating slow prototype ActionScripts into C++.
  Prototype in Flash on a fast machine, convert the scripts and
  deliver a blazing fast executable.

* Would be good if one of the log options produced a nice usable
  human-readable parsing of the file.  Or even a SSWF equivalent?


ActionScript
============

* sprites can receive button events!  Like mouse down/up, etc.  So
  need the appropriate machinery for watching the mouse.

* make sure the frame semantics are correct.  I'm not 100% clear on
  the semantics of frame transitions.  I think that "being on frame N"
  means that N's tags and actions have been executed.

* collect a canonical set of test movies and check them into CVS

* generate or collect some game-gui-like movies

* will need some good test programs to make sure VM is doing the right
  thing.

* implement each opcode and library function


Renderer
========

* optimize tesselator (not super-high priority, caching works pretty
  well)

  * improve naive (mis)use of array<>; use a more statically-allocated
    array to hold intermediate results.

  * examine use of qsort; should probably use pointers to stuff in
    some situations, instead of raw copies

  * coarse clip/cull

  * better tesselation; look at Shewchuck's constrained delaunay stuff
    or the improved trapezoid tesselator that doesn't cut across the
    whole shape

* real lines (low priority)

  I think the way to handle this is to take advantage of a (mipmapped)
  circle texture, say 16x16, and actually draw rectangles.  But then
  it still doesn't seem too easy to get right.  Needs more thinking.
  Not a super high priority; doesn't seem to be a critical feature for
  most movies.

* Idea for antialiasing.  I really miss antialiasing; it sure would be
  nice to have it.  (But this is low priority for productizing; it
  should be easy enough for designers to work around gameswf's
  limitations.)  So here's the idea:

  * do full-blown expensive cached tesselation, to generate a "fringe
    mesh" around the outside edges of shapes.  We know the range of
    desired rendering sizes (in pixels), so we can make a fringe mesh
    that will range from 1 to 2 pixels in width when rendered.  I
    believe this involves shrinking the interior of the mesh by the
    equivalent of a half-pixel.

  * render the mesh using the dual-textured modulate thing, to fade
    the edge.  Adjust the U coordinates of the outer edge of the
    fringe according to the actual size in pixels of the fringe;
    i.e. if the fringe is being rendered at 1.27 pixels in size,
    adjust U so that the alpha fades to exactly 0 when the fringe is
    1.0 pixel from the interior; the excess fringe has alpha == 0 so
    doesn't render.

  This sounds pretty foolproof to me.  It's expensive in terms of
  precomputation, but then we have all this precomputation machinery
  anyway, so no big deal.  There could possibly be a pop when
  tesselations switch, although I don't think it would be any worse
  than existing pops, and I haven't noticed any objectionable popping
  with our existing shape rendering.

  Self-intersection of the expanded/shrunk mesh is a bitch.
  E.g. concave vertices, and tiny holes (like in minified text).
