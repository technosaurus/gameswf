Bugs
====

* are sprite animations skipping slightly at the end?


Productizing
============

Tasks to make gameswf ready for including in real games.

* remove filename and FILE for caching in fontlib, and replace with
  tu_file* abstraction.

* abstract sound handler, that host apps can register.  Demonstrate
  this in the test program using SDL_mixer.  Need to implement sound
  tag parsing also.

* abstract the renderer?  Probably it's OK to just compile the
  renderer you want; this seems lower priority.  Need an Xbox renderer
  anyway.

* a good way to pre-compute tesselations of shapes.  Also, it would be
  very nice to be able to restrict the size of font textures for
  particular fonts that don't need to be scaled up.  RAM is precious.

  Here's what I'm thinking:

  * pass a flag to gameswf_test_ogl, like we do now for font caching.
    Specify any number of .swf movies.

  * the program loads all the movies and executes all the frames.
    This causes all the shapes to be tesselated to necessary levels,
    and the fonts to be precomputed, etc.  With the fonts, we should
    probably record the maximum size any font was displayed at; if
    it's small, then we can store smaller versions of the font
    textures.

  * append all the cached info as EXTRA CUSTOM TAGS right onto the
    ends of the associated .swf files.  So the .swf's are still valid,
    they just have a bunch of extra precompiled data on the end for
    the use of gameswf.

  * at load time, when we see these extra tags, we jam the data right
    into the corresponding characters without having to compute it.

* verify that library itself doesn't require SDL; avoid gratuitous
  c-library dependencies (I think we're mostly OK there)

* fix memory leaks

* pick a version number, post a release

* try to keep external #includes out of gameswf.h -- currently the
  render_handler has the bulk of the external dependencies.


General
=======

* text rendering is almost production-ready, so finishing touches here
  are a high priority.  In particular:

  * implement host-app driven text rendering functions

  * try it out; maybe add a little text output to chunklod or
    something

  * there's a pop when transitioning from textured to mesh-rendered
    glyphs; probably the texture fonts aren't registered exactly
    right?

* sprites as button characters are not working.  (Maybe they are
  now??)

* the half-implemented action stuff is an obstacle to progress; many
  of my test movies don't work because "goto frame" and/or some other
  actions are not working correctly.  Need to fix this.  Ideas:

  * disable all but the very simplest actions (i.e. up to SWF 4.0 or
    so), while working out the basics

  * make sure the frame semantics are correct.  I'm not 100% clear on
    the semantics of frame transitions.  I think that "being on frame
    N" means that N's tags and actions have been executed.  "goto N"
    is still unclear to me: does it mean that N's tags and actions
    should be executed, or do we start with N+1?  Does the display
    list need to be cleared, left as-is, or set to some pristine
    condition for frame N?  But the display list is built
    incrementally.  So this needs experimentation.  I haven't looked
    at flashsource's GPL code for this; maybe that will clear things
    up.

  * collect a canonical set of test movies and check them into CVS

  * generate or collect some game-gui-like movies

* host-app to gameswf communication

  * some mechanism for gamepad-like control of SWF UI's.  SWF is
    oriented around a mouse & keyboard model, which is not a good fit
    for consoles (and console-like) UI's.  Not sure exactly what to do
    about this.  One element would be associating SWF buttons with
    specific gamepad/keyboard buttons, which could be done by tagging
    the buttons in the SWF with special names, and adding an API for
    the host to report gamepad button presses.  Another element is
    dealing with dpad selections, where the user uses
    up/down/left/right buttons to highlight different options on the
    screen, and then another button to accept.  Not sure of the best
    way to shoehorn this into SWF.

    Current best idea: map gamepad buttons to keyboard keys, and use
    ActionScript to interpret keypresses.  Need enough ActionScript
    support so that this works.

* text entry?  No keyboard on consoles, text input is very platform
  specific; low priority for now.

* named elements APIs, for easier UI programming in the host app

* ActionScript needs to basically work

* Would be good if one of the log options produced a nice usable
  human-readable parsing of the file.  Or even a SSWF equivalent?


Renderer
========

* optimize tesselator (not super-high priority, caching works pretty
  well)

  * improve naive (mis)use of array<>; use a more statically-allocated
    array to hold intermediate results.

  * examine use of qsort; should probably use pointers to stuff in
    some situations, instead of raw copies

  * coarse clip/cull

  * better tesselation; look at Shewchuck's constrained delaunay stuff
    or the improved trapezoid tesselator that doesn't cut across the
    whole shape

* real lines (low priority)

  I think the way to handle this is to take advantage of a (mipmapped)
  circle texture, say 16x16, and actually draw rectangles.  But then
  it still doesn't seem too easy to get right.  Needs more thinking.
  Not a super high priority; doesn't seem to be a critical feature for
  most movies.

* Idea for antialiasing.  I really miss antialiasing; it sure would be
  nice to have it.  (But this is low priority for productizing; it
  should be easy enough for designers to work around gameswf's
  limitations.)  So here's the idea:

  * do full-blown expensive cached tesselation, to generate a "fringe
    mesh" around the outside edges of shapes.  We know the range of
    desired rendering sizes (in pixels), so we can make a fringe mesh
    that will range from 1 to 2 pixels in width when rendered.  I
    believe this involves shrinking the interior of the mesh by the
    equivalent of a half-pixel.

  * render the mesh using the dual-textured modulate thing, to fade
    the edge.  Adjust the U coordinates of the outer edge of the
    fringe according to the actual size in pixels of the fringe;
    i.e. if the fringe is being rendered at 1.27 pixels in size,
    adjust U so that the alpha fades to exactly 0 when the fringe is
    1.0 pixel from the interior; the excess fringe has alpha == 0 so
    doesn't render.

  This sounds pretty foolproof to me.  It's expensive in terms of
  precomputation, but then we have all this precomputation machinery
  anyway, so no big deal.  There could possibly be a pop when
  tesselations switch, although I don't think it would be any worse
  than existing pops, and I haven't noticed any objectionable popping
  with our existing shape rendering.
