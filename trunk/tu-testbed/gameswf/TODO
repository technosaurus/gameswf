General
=======

* test basic action stuff with a sample UI movie

* implement an event queue so the host app can get UI & animation
  events out of the player

* bitmapped fonts; not a native part of swf, but should be a good win
  in rendering speed on most hardware.  Perhaps render the font glyphs
  off to a texture, and pull them out at run-time instead of drawing
  the outline shapes.

  Alternative: make a separate tool that processes .swf's, and
  substitutes conventional text with bitmap shapes.  This actually
  sounds pretty good to me; reduces the amount of work at playback
  time.

* text entry?  No keyboard on consoles, text input is very platform
  specific; low priority for now.

* dynamic text fields -- necessary for most games, console or not.
  Given dynamic text, host app can hack in text entry.

* test multiple movies

* some way to hook up SWF buttons to logical app buttons (for gamepad
  UI).

* expose text rendering to host app

* named elements, for easier UI programming in the host app

* more action stuff


Renderer
========

It's horribly slow right now, and has some glitches :(

* radial gradients (just use a 16x16 texture or something)

* antialiasing

  Do it using alpha channel in font textures.  For general vector
  shapes, probably just punt.  Provide sample setup for hardware
  assist (multisample or whatever).  Leave the decision up to the app.

* optimizations

  * treat line segments as true line segments, instead of a flat curve.

  * get rid of naive (mis)use of array<>

  * coarse clip/cull

  * pre-cache shape tesselation?  Re-gen on the fly based on scale;
	with hysteresis.  Or is there some nice precomputation we can do
	without evaluating specific curve points, and then just rip
	through making strips & fans?

  * turn outline fonts into textures, render glyphs using textured
    quads.

* real lines

  Approach: within a path that has a line style, save the coords that
  come in and keep them in line-strip order.  Then, at the end of
  end_shape(), trace them out directly, including rounded edges.

  Better (?): generate an outline from the line definition.

  Real rounded lines actually seem trickier the more I think about
  them.
