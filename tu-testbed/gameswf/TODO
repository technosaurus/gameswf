General
=======

* text rendering is almost production-ready, so finishing touches here
  are a high priority.  In particular:

  * implement host-app driven text rendering functions

  * try it out; maybe add a little text output to chunklod or
    something

* sprites as button characters are not working.

* the half-implemented action stuff is an obstacle to progress; many
  of my test movies don't work because "goto frame" and/or some other
  actions are not working correctly.  Need to fix this.  Ideas:

  * disable all but the very simplest actions (i.e. up to SWF 4.0 or
    so), while working out the basics

  * make sure the frame semantics are correct.  I'm not 100% clear on
    the semantics of frame transitions.  I think that "being on frame
    N" means that N's tags and actions have been executed.  "goto N"
    is still unclear to me: does it mean that N's tags and actions
    should be executed, or do we start with N+1?  Does the display
    list need to be cleared, left as-is, or set to some pristine
    condition for frame N?  But the display list is built
    incrementally.  So this needs experimentation.  I haven't looked
    at flashsource's GPL code for this; maybe that will clear things
    up.

  * collect a canonical set of test movies and check them into CVS

* host-app to gameswf communication

  * some mechanism for gamepad-like control of SWF UI's.  SWF is
    oriented around a mouse & keyboard model, which is not a good fit
    for consoles (and console-like) UI's.  Not sure exactly what to do
    about this.  One element would be associating SWF buttons with
    specific gamepad/keyboard buttons, which could be done by tagging
    the buttons in the SWF with special names, and adding an API for
    the host to report gamepad button presses.  Another element is
    dealing with dpad selections, where the user uses
    up/down/left/right buttons to highlight different options on the
    screen, and then another button to accept.  Not sure of the best
    way to shoehorn this into SWF.

    Current best idea: map gamepad buttons to keyboard keys, and use
    ActionScript to interpret keypresses.  Need enough ActionScript
    support so that this works.

* packaging

  * verify that library itself doesn't require SDL

  * libjpeg and libz dependencies are necessary, so leave as-is

  * Xbox port (important to me personally; maybe not a high priority
    for others)

  * pick a version number, post a release

* text entry?  No keyboard on consoles, text input is very platform
  specific; low priority for now.

* dynamic text fields -- necessary for most games, console or not.
  Given direct text-rendering calls, host app can hack in text entry,
  so don't prioritize this yet.

* named elements APIs, for easier UI programming in the host app

* ActionScript needs to basically work


Renderer
========

It's horribly slow right now, and has some glitches :(

* antialiasing (probably just give up; textured text glyphs are pretty
  nice and address the major requirement of smooth text)

  * in a "good enough for now" condition; currently using a half-pixel
    half-transparent line around the outside of shapes, and textured
    rendering for text.  Text looks good up to a certain size; maybe
    do some scale analysis to switch to outline rendering when text
    size goes above some threshold.

    Drawback of blurry-outline is that it expands the shape.  Keep
    thinking about the problem; no immediate good solution is
    currently known.

* optimizations

  * treat line segments as true line segments, instead of a flat curve.

  * get rid of naive (mis)use of array<>; use a more
    statically-allocated array to hold intermediate results.

  * coarse clip/cull

  * tulrich: DOING THIS: precompute shape tesselation.  Re-gen on the
    fly based on scale as necessary, cache the results in each shape
    character.  Cache has a list of fill styles plus a list of
    vertices & triangles per fill style (i.e. a mesh), for the
    renderer to just rip through in a hurry.

* real lines (low priority)

  I think the way to handle this is to take advantage of a (mipmapped)
  circle texture, say 16x16, and actually draw rectangles.  But then
  it still doesn't seem too easy to get right.  Needs more thinking.
  Not a super high priority; doesn't seem to be a critical feature for
  most movies.
